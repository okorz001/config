# ~/.gitconfig
# vim:ft=cfg:

[user]
    # User name for commits.
    name = Oscar Korz

    # Email for commits.
    email = okorz001@gmail.com

[github]
    # Github account name.
    user = okorz001

[core]
    # Editor for commit messages.
    editor = vim

    # Pager for multi-screen output.
    pager = less

    # A file of exclude patterns to apply to all repos.
    excludesfile = ~/.gitignore

[push]
    # If no arguments given, abort.
    # This prevents the accidental push of a private local branch.
    default = nothing

[merge]
    # Create local, remote and original.
    conflictstyle = diff3

    # Use vimdiff to merge in a terminal.
    tool = vimdiff

[color]
    # Colorize all output if the terminal supports it.
    ui = auto

[color "branch"]
    current = cyan bold
    local = green
    remote = red

[color "decorate"]
    head = cyan bold
    branch = green
    remoteBranch = red
    tag = cyan
    stash = yellow bold

[color "status"]
    branch = cyan bold
    nobranch = white red bold
    header =
    added = green
    changed = yellow
    untracked = red

[alias]
    # Two-letter abbreviations because I'm lazy.
    br = branch
    ci = commit
    co = checkout
    st = status
    sub = submodule

    # pi is short for pick. cp is a bad idea... :)
    pi = cherry-pick

    # Sync our view of all remotes. We should have a perfect mirror now.
    # --prune drops all remote branches that are now stale (have been deleted).
    # --tags fetchs tags that are otherwise unreachable by branches.
    sync = fetch --prune --tags --all

    # Get the current SHA1 hash.
    where = log --pretty=format:%H -1

    # Quick and dirty history graph. Good for cherry-picking/rebasing.
    l1 = log --pretty=oneline --abbrev-commit --decorate --graph --all
    lf = log --pretty=fuller --decorate --graph --stat

    # Git has mv, so why not cp?
    # If $# > 2, this could stage other local changes...
    cp = "!sh -c 'cp $@ && git add ${@:$#}' -"
